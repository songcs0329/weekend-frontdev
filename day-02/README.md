# 스터디 2회차 정리

값 : 값(피연산자) 연산자 값(피연산자)  
값 : 식  
리터럴 : 소스코드의 고정된 값을 대표하는 용어  
EX)  
x = 1 + 2  
= : 대입 or 할당 연산자  
우변(1 + 2)이 좌변(x)에 할당된다.  
x : 변수  
x = x + 1 === x += 1  
x = x * 2 === x *= 2  
  
1. 식은 값으로 귀결됨
2. 대입연산자 기준 좌측 = 변수, 우측 = 값(식)
3. 변수(값에 부여한 의미) = 값을 임시로 기억할 때 사용

항 갯수에 따른 연산자 분류
1. 단항연산자
2. 이항연산자
3. 삼항연산자

연산자 위치에 따른 분류
1. 전위연산자
2. 중위연산자
3. 후위연산자

값의 특성
1. 피연산자
2. 식의 결과
3. 변수에 할당가능

string = string + string  
boolean = number > number  
y = typeof 55  === string = typeof number  
string = typof 뭐시기  

변수
1. 식별자
2. 임시적상태
변수가 많으면 예측이 까다롭고 읽기 힘들어짐  
(변수의 상태변화를 계속 갱신하면서 코드를 읽어야한다!)

답은 주어져있고 그 답을 구하는 식을 작성, 그 식에 이름 붙이는 행위의 반복  
답 = 요구사항, 식 = 알고리즘, 이름 = 식별자  

함수  
y = f(x) === 떡 = 방앗간기계(쌀)  
시금치떡 = 방앗간기계(쌀, 시금치) or 초록떡 = 방앗간기계(쌀, 시금치) or 뭐시기 = 방앗간기계(쌀, 시금치) or 시금치떡 = 거시기(쌀, 시금치)

변수명, 함수명같은 식별자는 작성자 관점에 따라 다르다. === 네이밍이 제일 어렵다!

riceCake = machine(rice) === riceCake = 함수(값) === riceCake = 값

1. 선언
2. 호출(실행)

function 함수명() {  
    // 함수본문  
}  

EX)
result = sum(10, 20) // 소비자관점  
function sum(a,b) { // a,b : 파라미터(parameter)  
    return a + b; // return : 함수밖으로 결과값 반환, return을 만나면 함수 즉시 종료됨  
} // 생산자관점  
선언만으로는 아무일도 발생x  
sum(5,6) // 5,6: 파라미터에 할당될 값 = 인자(argument)  
호출을 해야 동작  
function f() {  
    return; // 명시하면 그 값, 아니면 undefined return  
}  

익명함수: 값으로 사용될때 함수는 이름이 없어도 된다
1. 변수에 할당
2. 함수의 반환값으로 사용
3. 인자로 사용

EX)
1. sum = function(a,b) {  
    return a + b;  
} // 익명함수를 sum 변수에 할당  

2. function sum(a) {  
    return fuction(b) {  
        return a + b;  
    }  
} // 익명함수를 반환하는 함수 sum  

3. on("click", function(e) { // 이런애들이 콜백함수(함수를 실행할지 말지는 on이 결정)  
    // 로직  
}) // on함수를 호출하면서 인자로 사용  
f = function(e) {  
    // 로직  
}  
on("click", f) // 변수 f에 익명함수 할당, on함수 호출 시 변수 f 인자로 사용

콜백함수  
인자로 사용되며 호출제어권을 이전하는 함수  
함수를 실행할지 말지는 on이 결정  